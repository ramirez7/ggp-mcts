\documentclass[letterpaper]{article}
% Required Packages
\usepackage{aaai}
\usepackage{times}
\usepackage{helvet}
\usepackage{courier}
\usepackage{listings}
\lstset{language=Lisp, basicstyle=\footnotesize}
\usepackage{caption}
\DeclareCaptionFont{white}{ \color{white} }
\captionsetup[lstlisting]{singlelinecheck=false, margin=0pt, font={bf,footnotesize}}
\setlength{\pdfpagewidth}{8.5in}
\setlength{\pdfpageheight}{11in}
\nocopyright
% Title
\title{General Game Playing and Monte-Carlo Tree Search}
\author{Armando Ramirez \\ Purdue University, West Lafayette, IN \\ ramirez7@purdue.edu \\ armando.m.ramirez@gmail.com}
% Body
\begin{document}
\maketitle

\section{Introduction}

\section{Critique}

\subsection{Background}

\subsubsection{General Game Playing}
The General Game Playing Competition is an annual competition created and managed by Stanford University in which game-playing agents compete playing games of which they have no prior knowledge.\cite{StanfordGGP} This means they cannot use any heuristical knowledge (unless they can infer some from the game description) and must use more general methods of game-playing. Games occur with two or more agents communicating synchronously with a Game Master. The Game Master first tells the agents the rules of the game, and then for the rest of the game it is responsible for receiving player input and telling the players the next state of the game. All moves are synchronous, but turn-based games are easily simulated by the game rules requiring all but the active player to pass.

All the games played at the competition are described in Game Description Language (also known as Game Definition Language.) Games are boiled down to their most general essence when expressed in this language. A game description is composed of a series of relations. While the game can define its own game-specific relations, there are set relations that must be defined for all games. They are listed below, as described on the Stanford General Game Playing website \cite{StanfordGGP}.
\begin{itemize}
%TODO: italicize relations
\item role(a) means that a is a role in the game.
\item base(p) means that p is a base proposition in the game.
\item input(r,a) means that a is an action for role r.
\item init(p) means that the proposition p is true in the initial state.
\item true(p) means that the proposition p is true in the current state.
\item does(r,a) means that player r performs action a in the current state.
\item next(p) means that the proposition p is true in the next state.
\item legal(r,a) means it is legal for role r to play action a in the current state.
\item goal(r,n) means that player the current state has utility n for player r.
\item terminal means that the current state is a terminal state.
\end{itemize}

The true and does relations are in effect inputs. The true relations are inputs to the agents from the Game Master, and the does relation is the input from the agents to the Game Master. Therefore, all of the above relations except those two should be defined (most likely in terms of true and does) in the GDL description of a game.

\subsubsection{Monte-Carlo Tree Search}

\subsection{FINNSSON}

\subsection{LONG}

\subsection{MC-RAVE}

\section{Implementation}

\subsection{Background}

\subsubsection{Clojure}
The implementation of General Game Playing Monte-Carlo Tree Search presented in this paper was implemented in the programming language Clojure. Clojure is a Lisp dialect that can be compiled to run on the Java Virtual Machine, .NET Common Language Runtime, and JavaScript Virtual Machine. It was chosen for a variety of reasons
\begin{itemize}
% TODO: BOLD TITLE TERMS
\item Data Structures Clojure has a rich collection of immutable, persistent data structures including lists, vectors, sets, and maps.
\item Libraries Clojure has multiple libraries suited for the project, including pattern matching and logic programming libraries.
\item Highly Functional Clojure has a large set of higher-order functions that can operate on any of its collections.
\item Homoiconicity Part of this project involves translating Game Description Language into Clojure. This task would not have been possible in the timespan it was done in in a language that is not code-as-data.
\item Comfort On a personal level, I am most comfortable programming in Clojure.
\end{itemize}
\subsubsection{core.logic}
%FIXME: CAN'T LINEBREAK AFTER THIS SUBSUBSECTION
The primary Clojure library used in the implementation was core.logic, which is a port of the logic programming language miniKanren as formulated by William Byrd in his 2010 PhD thesis \cite{byrd2010relational}. miniKanren and core.logic are logic programing languages, which means that they deal in relations rather than functions. To get a feel for what that means, consider the + Clojure function compared to the + core.logic relation:

\begin{lstlisting}[frame=single, caption=The + function]
REPL:> (+ 2 3)
5
\end{lstlisting}

\begin{lstlisting}[frame=single, caption=The + relation]
REPL:> (run* [q] (+ 2 3 q))
(5)
REPL:> (run* [q] (+ 2 q 5))
(3)
REPL:> (run* [q] (+ q 3 5))
(2)
REPL:> (run* [q] (+ 2 3 5))
(._0) ;; SUCCESS
REPL:> (run* [q] (+ 2 3 7))
() ;; FAILURE
\end{lstlisting}

(Note: The (run* [q] \textless RELATION\textgreater) means 'give me all the values of q such that the relation (with q substituted in) succeeds')

There are some key differences:
\begin{itemize}
\item The + function takes two arguments, a and b, and returns a+b, whereas the + relation takes three arguments, a b and c, and is the declaration that a+b=c.
\item This difference allows the relation to run backwards (in effect, performing subtraction.)
\item The relation doesn't run a number. It returns a list of numbers.
\end{itemize}

core.logic also allows the user to declare 'fresh' variables (which are free until bound) to work with. It also provides a relational disjunction in the form of conde. Finally, it offers unification ('==') to constrain logic variables. To show these in action (and to show a more complex example of core.logic), consider the below relation and its evaluation:

\begin{lstlisting}[frame=single, caption=Relation to generate all pairs of whole numbers (x y) such that x+y equals 3 or 4]
(defn pair-example [p]
  (fresh [x y]
    (== [x y] p)
    (in x y (interval 0 4))
    (conde
      [(+ x y 3)]
      [(+ x y 4)])))

REPL:> (run* [q] (pair-example q))
([0 3] [0 4] [1 2]
 [1 3] [2 1] [2 2]
 [3 0] [3 1] [4 0])
\end{lstlisting}

This example exposes the under-workings of core.logic: It is, in effect, abstracted search. The user declaratively tells the system what he is looking for, and core.logic performs the search and returns all the solutions it finds. In the context of General Game Playing, these attributes of relations are extremely useful. For example, the legal relation can be used to both generate (via search) all legal moves and check if a move is legal.

\subsection{GDL Translation to core.logic}
\subsubsection{Motivation}
Game Description Language is trivially derived from English. Below are the English and GDL descriptions of legality in Tic-Tac-Toe.
\begin{lstlisting}[frame=single, caption=The Legal relation for Tic-Tac-Toe expressed in English]
;It is Legal for player w to mark cell (m,n)
;if it is true that cell (m,n) is blank and
;it is true that it is player w's turn to
;move. If it is X's turn to move, O can only
;noop. If it is O's turn to move, X can only
;noop. 
\end{lstlisting}
\begin{lstlisting}[frame=single, caption=The Legal relation for Tic-Tac-Toe expressed in GDL]
(<= (legal ?w (mark ?m ?n))
    (true (cell ?m ?n b))
    (true (control ?w)))

(<= (legal X noop)
    (true (control O)))

(<= (legal O noop)
    (true (control X)))
\end{lstlisting}

Similarly, a corresponding core.logic relation can be derived from the GDL description.

\begin{lstlisting}[frame=single, caption=The Legal relation translated into core.logic]
(defn legal [role action]
 (conde
  [(fresh [?w ?m?n]
    (== role ?w)
    (== action [:mark ?m ?n])
    (true [:cell ?m ?n :b])
    (true [:control ?w]))]
  [(== role :X)
   (== action :noop)
   (true [:control :O])]
  [(== role :O)
   (== action :noop)
   (true [:control :X])]))
\end{lstlisting}

While the core.logic version is more verbose, each part has a direct correspondence(SP?) to part of the GDL description:
\begin{itemize}
\item The relation has an explicit declaration with argument names.
\item All the reflexive relations at the head of each GDL \textless= block are transformed into a series of unifications with the corresponding GDL arguments. 
\item All free variables in the GDL relation are now explicitly declared in a core.logic fresh block.
\item The three separate GDL relations are now combined in a single conde block. In the GDL description, there is an implicit disjunction between the relations. conde is a core.logic disjunction.
\end{itemize}

\subsubsection{Implementation}

\subsubsection{Results}
The translation algorithm was tested on four Game Description Language descriptions that can be found on the Stanford Gamemaster website: Tic-Tac-Toe, Chinkook, Chinese Checkers, and Pentago. These games are diverse in factors such as board structure, number of players, types of moves, synchronicity (??) of moves, etc (!!).

\subsection{Monte-Carlo Tree Search}

\subsection{Goal Stability Early Cutoff}
Due to the modular nature of the Monte-Carlo Tree Search code, it was easy to implement the Goal Stability Early Cutoff extension \cite{finnsson2012generalized}. In the playout function, which originally just randomly plays a game to completely, a list of the result of the Goal relation is stored for each player.

Below is a code snippet (with some parts redacted for conciseness) of the core decision making process implemented.
\begin{lstlisting}[frame=single,caption=Clojure implementation of Goal Stability Early Cutoff]
(if (or (terminal? env)
        (and use-early-cutoff?
        (is-goal-stable? goals threshold)
        (>= steps cut)))
     ;; Simulation over
     scores
     ;; Simulation not over.
     ;; Choose random child.
     (recur (rand-nth (gen-children env)) 
            next-goals (inc steps)))
\end{lstlisting}

The implementation did not break any game that was played using it; however, none of the games that were used for testing had a fine-grained enough Goal relation for the Goal Stability Early Cutoff extension to frequently (or sometimes ever) come into effect.

\section{Future Work}

Of the extensions listed in the critiqued paper, only Finnsson's Goal Stability Early Cutoff extension was incorporated into my Monte-Carlo Tree Search algorithm. Future work would entail implementing a variety of extensions and improvements, including but not limited to UCT, MC-RAVE, Terminal Interval Early Cutoff, and Unexplored Action Urgency. In addition, the game descriptions used from the Stanford Gamemaster website were all for the most part not applicable to the extension implemented, and to some of the extensions not implemented. Future work would examine these extensions in contexts where they are most suited.

The Game Description Language to core.logic transformation algorithm stands to be extremely useful in a variety of contexts. As such, I plan on publishing my work to the appropriate Clojure repositories, such as Leiningen. This would entail a good deal work to make the code publishable, including performing more rigorous testing and writing very thorough documentation.

Finally, the Game Description Language to core.logic transformation algorithm has applications outside of artifical intelligence. It stands to reason that it could be used as the underlying logic of a graphical user interface implementation of a variety of games. Due to the expressivity of Game Description Language, the ability to write the game logic in GDL would vastly speed up the development time of the game engine.

\section{Conclusion}

% References
\bibliography{paper}
\bibliographystyle{aaai}
\end{document}
