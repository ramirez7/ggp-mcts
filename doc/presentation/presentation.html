<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      /* Slideshow styles */
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# General Game Playing and Monte Carlo Tree Search
### Armando Ramirez
---

# Agenda

1. Introduction
2. Deep-dive
3. ...

<!-- EXAMPLE IMAGE-->
<img src = "mctsfigure.png" style="height:auto; width:auto; max-width:1000px; max-height:1000px;">
---
# Introduction
```Clojure
(defn f [x] 
  (cond
    (= 1 x) (respond :yes)
    :else (respond :nope)))
```

---

# core.logic: Functions vs Relations
## The plus function
```
REPL:> (+ 2 3)
```
## The plus relation
```
REPL:> (run* [q] (+ 2 3 q))
(5)
REPL:> (run* [q] (+ 2 q 5))
(3)
REPL:> (run* [q] (+ q 3 5))
(2)
REPL:> (run* [q] (+ 2 3 5))
(._0) ;; SUCCESS
REPL:> (run* [q] (+ 2 3 7))
() ;; FAILURE
```
* The (run* [q] RELATION) macro means “give me all the values of q such that the relation (with q substituted in accordingly) succeeds”

---
# core.logic: More complex example
```Clojure
(defn pair-example [p]
  (fresh [x y]
    (== [x y] p)
    (in x y (interval 0 Infinity))
    (conde
      [(+ x y 3)]
      [(+ x y 4)])))
```

```
REPL:> (run* [q] (pair-example q))
([0 3] [0 4] [1 2]
 [1 3] [2 1] [2 2]
 [3 0] [3 1] [4 0])

```
---
# Motivation: English->GDL->core.logic
### English

It is Legal for player **w** to mark cell (**m**,**n**) if it is true that cell (**m**,**n**) is blank and it is true that it is player **w**'s turn to move. If it is X's turn to move, O can only noop. If it is O's turn to move, X can only noop. That is, they take turns.


---
# Motivation: English->GDL->core.logic
### English

It is Legal for player **w** to mark cell (**m**,**n**) if it is true that cell (**m**,**n**) is blank and it is true that it is player **w**'s turn to move. If it is X's turn to move, O can only noop. If it is O's turn to move, X can only noop. That is, they take turns.

### GDL

```Clojure
(<= (legal ?w (mark ?m ?n))
    (true (cell ?m ?n b))
    (true (control ?w)))

(<= (legal X noop)
    (true (control O)))

(<= (legal O noop)
    (true (control X)))

```

---
# Motivation: English->GDL->core.logic
### English

It is Legal for player **w** to mark cell (**m**,**n**) if it is true that cell (**m**,**n**) is blank and it is true that it is player **w**'s turn to move. If it is X's turn to move, O can only noop. If it is O's turn to move, X can only noop. That is, they take turns.

### GDL

```Clojure
(<= (legal ?w (mark ?m ?n))
    (true (cell ?m ?n b))
    (true (control ?w)))

(<= (legal X noop)
    (true (control O)))

(<= (legal O noop)
    (true (control X)))

```

### core.logic

```Clojure
(defn legal [role action]
 (conde
  [(fresh [?w ?m ?n]
    (== role ?w)
    (== action [:mark ?m ?n])
    (true [:cell ?m ?n :b])
    (true [:control ?w]))]
  [(== role :X)
   (== action :noop)
   (true [:control :O])]
  [(== role :O)
   (== action :noop)
   (true [:control :X])]))
```
---
# Motivation: Use of core.logic legal relation
### Legality checking
```
REPL:> (run* [q] (legal :X [:mark 1 1]))
(._0) ;; SUCCESS
REPL:> (run* [q] (legal :O [:mark 1 1]))
() ;; FAILURE. O cannot mark any square
```
### Legal move generation
```
REPL:> (run* [q] (legal :X q))
([:mark 3 3] [:mark 3 2] [:mark 3 1]
 [:mark 2 3] [:mark 2 2] [:mark 2 1]
 [:mark 1 3] [:mark 1 2] [:mark 1 1])
REPL:> (run* [q] (legal :O q))
(:noop)
```
---
# Implementation: GDL->core.logic
## The Environment
* Runs through arbitrary GDL description and generates an *environment* that represents game rules and state
* Each relation now takes an extra argument of the environment so that it can call other relations in the GDL translation:

```Clojure
;; :legal
(fn [env role action]
 (conde
  [(fresh [?w ?m ?n]
    (== role ?w)
    (== action [:mark ?m ?n])
    ((get-relation env :true) [:cell ?m ?n :b])
    ((get-relation env :true) [:control ?w]))]
  [(== role :X)
   (== action :noop)
   ((get-relation env :true) [:control :O])]
  [(== role :O)
   (== action :noop)
   ((get-relation env :true) [:control :X])]))

(defn get-relation [env r]
  (partial (env r) env))
```
---
# Implementation: GDL->core.logic
## Pre-processing

---
# Implementation: GDL->core.logic
## Translation rules
### Reflexive head calls turn into unifications of args

```Clojure
;; Transforming Legal
(legal ?w (mark ?x ?y))
;; -~->
(== role ?w)
(== move [:mark ?x ?y])
```
### All other relations reference the environment

```Clojure
(true (cell 1 1 b))
;; -~->
((get-relation env :true) [:cell 1 1 :b])
```

### not turns into negation as failure constraint (nafc)
```Clojure
(not (line X))
;; -~->
(nafc (env :line) env :X)
```
---
# Implementation: GDL->core.logic
## Translation rules
### Relation are joined in a fresh block
```Clojure
(<= (head & args)
    & tail)
;; -~->
(fresh [fresh-vars]
 (transformed head)
 (transformed tail))
```
### Multiple related relations are joined by a disjunction (conde)
```Clojure
(relation1)
(relation2)
;; ...
(relationN)
;; -~->
(conde
 [(transformed relation1)]
 [(transformed relation2)]
 ;; ...
 [(transformed relationN)])
```
---
<!--http://gnab.github.io/remark/downloads/remark-0.5.9.min.j-->
    </textarea>
    <script src="remark-0.5.9.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
